在`GoFrame`框架中，秉承着代码分层的思想，开发任意一个接口都可以用到"三板斧"法则：`添加Api，生成控制器`、`编写Logic逻辑`、`控制器调用Logic`。
## 添加Api
---
*api/users/v1/users.go*
```go
package v1

import "github.com/gogf/gf/v2/frame/g"

type RegisterReq struct {
    g.Meta   `path:"users/register" method:"post"`
    Username string `json:"username"`
    Password string `json:"password"`
    Email    string `json:"email"`
}

type RegisterRes struct {
}
```

新增一个注册用户的接口，接口地址为`/users/register`，请求方式为`POST`。
执行命令生成`Api`对应的`Controller`：
```bash
$ gf gen ctrl
generated: D:\project\star\api\users\users.go
generated: internal\controller\users\users.go
generated: internal\controller\users\users_new.go
generated: internal\controller\users\users_v1_register.go
done!
```

> 如果你已经安装了[GoFrame Helper](https://plugins.jetbrains.com/plugin/23324-goframe-helper)插件，会自动执行`gf gen ctrl`命令。如果你没有安装插件，可以参照官网[教程配置](https://goframe.org/docs/cli/gen-ctrl#%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%BC%8F%E6%8E%A8%E8%8D%90)自动生成。

## 编写Logic
---
所有业务的核心逻辑都应该存放在`internal/logic`下，供`Controller`层调用从而实现我们的业务逻辑。
*internal/logic/users/register.go*

```go
package users

import (
    "context"

    "star/internal/dao"
    "star/internal/model/do"
)

func Register(ctx context.Context, username, password, email string) error {
    _, err := dao.Users.Ctx(ctx).Data(do.Users{
        Username: username,
        Password: password,
        Email:    email,
    }).Insert()
    if err != nil {
        return err
    }
    return nil
}
```

## 控制器调用Logic
---
*internal/controller/users/users_v1_register.go*
```go
package users

import (
    "context"

    "star/internal/logic/users"

    "star/api/users/v1"
)

func (c *ControllerV1) Register(ctx context.Context, req *v1.RegisterReq) (res *v1.RegisterRes, err error) {
    err = users.Register(ctx, req.Username, req.Password, req.Email)
    return nil, err
}
```
## 注册控制器
---
*internal/cmd/cmd.go*
```go
package cmd

···

var (
    Main = gcmd.Command{
        Name:  "main",
        Usage: "main",
        Brief: "start http server",
        Func: func(ctx context.Context, parser *gcmd.Parser) (err error) {
            s := g.Server()
            s.Group("/", func(group *ghttp.RouterGroup) {
                group.Middleware(ghttp.MiddlewareHandlerResponse)
                group.Group("/v1", func(group *ghttp.RouterGroup) {
                    group.Bind(
                        users.NewV1(),
                    )
                })
            })
            s.Run()
            return nil
        },
    }
)
```

完成后运行项目：
```bash
$ gf run main.go
```
`gf run main.go`是`GF-CLI`提供的程序运行命令，当开发者修改了项目中的 `go` 文件时，该命令将会自动编译当前程序，并停止原有程序，运行新版的程序。相比`go run main.go`更为方便！

在命令行后会打印运行结果：
```bash
build: .\main.go
go build -o .\main.exe  .\main.go
.\main.exe 
build running pid: 8648
2024-11-08 10:36:48.013 [INFO] pid[8648]: http server started listening on [:8000]
2024-11-08 10:36:48.013 [INFO] {e05c16b565dd0518360ebe639e1c623d} swagger ui is serving at address: http://127.0.0.1:8000/swagger/
2024-11-08 10:36:48.014 [INFO] {e05c16b565dd0518360ebe639e1c623d} openapi specification is serving at address: http://127.0.0.1:8000/api.json

  ADDRESS | METHOD |       ROUTE        |                         HANDLER                         |           MIDDLEWARE
----------|--------|--------------------|---------------------------------------------------------|----------------------------------
  :8000   | ALL    | /api.json          | github.com/gogf/gf/v2/net/ghttp.(*Server).openapiSpec   |
----------|--------|--------------------|---------------------------------------------------------|----------------------------------
  :8000   | ALL    | /swagger/*         | github.com/gogf/gf/v2/net/ghttp.(*Server).swaggerUI     | HOOK_BEFORE_SERVE
----------|--------|--------------------|---------------------------------------------------------|----------------------------------
  :8000   | POST   | /v1/users/register | star/internal/controller/users.(*ControllerV1).Register | ghttp.MiddlewareHandlerResponse
----------|--------|--------------------|---------------------------------------------------------|----------------------------------
```

运行结果中打印出了三个接口地址。`/swagger` 和 `/api.json`是框架生成的接口文档地址，我们会在[2.5 - 接口文档](./2.5%20-%20接口文档.md)详细的说明它。现在我们需要关注第一个接口`/v1/users/register`。发起一个`POST`请求测试接口：
```bash
$ curl -X POST http://127.0.0.1:8000/v1/users/register -H "Content-Type: application/json" -d "{\"username\":\"oldme\", \"password\":\"123456\", \"email\":\"tyyn1022@gmail.com\"}"

{
    "code":0,
    "message":"",
    "data":null
}
```

`code`为`0`代表成功，去数据库查看是否插入了一条数据：

```sql
SELECT * FROM users;
```

| ID  | Username | Password | Email              | Created_At          | Updated_At          |
| --- | -------- | -------- | ------------------ | ------------------- | ------------------- |
| 1   | oldme    | 123456   | tyyn1022@gmail.com | 2024-11-08 10:36:48 | 2024-11-08 10:36:48 |

`Created_At`和`Updated_At`两个字段会被`ORM`自动维护，分表代表创建时间和修改时间。