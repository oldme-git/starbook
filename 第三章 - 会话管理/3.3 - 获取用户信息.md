前端从`Login`中获取`Token`后，在后续的请求流程中在`HTTP Header`中携带。我们需要编写一个**中间件/拦截器**来验证`Token`是否有效。

> 中间件/拦截器是处理 `HTTP` 请求和响应的函数或组件。它们通常用于在请求到达最终处理器之前或响应发送给客户端之前执行一些操作。

## Auth 中间件
---
`GoFrame` 提供了优雅的中间件请求控制方式， 该方式也是主流的 `WebServer` 提供的请求流程控制方式， 基于中间件设计可以为 `WebServer` 提供更灵活强大的插件机制。

*internal/logic/middleware/auth.go*
```go
package middleware  
  
import (  
    "net/http"  
    
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/golang-jwt/jwt/v5"
    "star/utility"
)  
  
func Auth(r *ghttp.Request) {  
    var (  
       jwtKey      = utility.JwtKey  
       tokenString = r.Header.Get("Authorization")  
    )  
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {  
       return jwtKey, nil  
    })  
    if err != nil || !token.Valid {  
       r.Response.WriteStatus(http.StatusForbidden)  
       r.Exit()  
    }  
  
    r.Middleware.Next()  
}
```

`r.Header.Get("Authorization")`这行代码获取`HTTP Header`中的`Authorization`，即获取前端传过来的`Token`。`jwt.Parse` 解析后再通过`token.Valid`验证是否有效，如果失效则返回 `HTTP StatusForbidden 403` 状态码。

## 添加Api
---
*api/account/v1/account.go*
```go
package v1  
  
import (  
    "github.com/gogf/gf/v2/frame/g"  
)  
  
type InfoReq struct {  
    g.Meta `path:"account/info" method:"get" sm:"获取信息" tags:"用户"`  
}  
  
type InfoRes struct {  
    Username  string      `json:"username" dc:"用户名"`  
    Email     string      `json:"email" dc:"邮箱"`  
    CreatedAt *gtime.Time `json:"created" dc:"创建时间"`  
    UpdatedAt *gtime.Time `json:"update" dc:"更新时间"`  
}
```

## 编写Logic
---
*internal/logic/users/account.go*
```go
package users  
  
import (  
    "context"  
    "errors"
    "time"  
    
    "github.com/gogf/gf/v2/frame/g"
    "github.com/golang-jwt/jwt/v5"
    "star/internal/dao"    
    "star/internal/model/entity"    
    "star/utility"
)

...

func Info(ctx context.Context) (user *entity.Users, err error) {  
    user = new(entity.Users)  
    tokenString := g.RequestFromCtx(ctx).Request.Header.Get("Authorization")  
  
    tokenClaims, _ := jwt.ParseWithClaims(tokenString, &UserClaims{}, func(token *jwt.Token) (interface{}, error) {  
       return utility.JwtKey, nil  
    })  
  
    if claims, ok := tokenClaims.Claims.(*UserClaims); ok && tokenClaims.Valid {  
       err = dao.Users.Ctx(ctx).Where("id", claims.Id).Scan(&user)  
    }  
    return  
}
```

## Controller调用Logic
---
*internal/controller/account/account_v1_info.go*
```go
package account  
  
import (  
    "context"  
    
    "star/api/account/v1"
    "star/internal/logic/users"
)  
  
func (c *ControllerV1) Info(ctx context.Context, req *v1.InfoReq) (res *v1.InfoRes, err error) {  
    user, err := users.Info(ctx)  
    if err == nil {  
       res = &v1.InfoRes{  
          Username:  user.Username,  
          Email:     user.Email,  
          CreatedAt: user.CreatedAt,  
          UpdatedAt: user.UpdatedAt,  
       }  
    }  
    return  
}
```

## 注册新的控制器
---
分组路由注册新的控制器时，将`Auth`中间件注入：
*internal/cmd/cmd.go*
```go
package cmd  
  
import (  
    "context"  
  
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/os/gcmd"
    "star/internal/controller/account"
    "star/internal/controller/users"
    "star/internal/logic/middleware"
)  
  
var (  
    Main = gcmd.Command{  
       ...
          s.Group("/", func(group *ghttp.RouterGroup) {  
             group.Middleware(ghttp.MiddlewareHandlerResponse)  
             group.Group("/v1", func(group *ghttp.RouterGroup) {  
                group.Bind(  
                   users.NewV1(),  
                )  
             })  
             group.Group("/", func(group *ghttp.RouterGroup) {  
                group.Middleware(middleware.Auth)  
                group.Group("/v1", func(group *ghttp.RouterGroup) {  
                   group.Bind(  
                      account.NewV1(),  
                   )  
                })  
             })  
          })  
        ...
       },  
    }  
)
```

这样，以后需要用户认证的控制器都可以放在第二个分组路由下，可以避免在每个控制器前都重新验证一遍用户。

### 接口测试
---
注意把`Authorization`换成自己的：
```bash
$ curl -H "Authorization: eyJhbGci...W6Ed_d3P77Mc" http://127.0.0.1:8000/v1/account/info

{
    "code":0,
    "message":"",
    "data":{
        "username":"oldme",
        "email":"tyyn1022@gmail.com",
        "created":"2024-11-08 17:02:16",
        "update":"2024-11-08 17:02:16"
    }
}
```