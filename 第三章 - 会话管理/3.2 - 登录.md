登录功能与注册功能类似，也是编写`api`生成`Controller`，编写核心逻辑`logic`，最后由`Controller`调起`Logic`。
## 添加登录Api
---
*api/users/v1/users.go*
```go
...
  
type LoginReq struct {  
    g.Meta   `path:"users/login" method:"post" sm:"登录" tags:"用户"`  
    Username string `json:"username" v:"required|length:3,12"`  
    Password string `json:"password" v:"required|length:6,16"`  
}  
  
type LoginRes struct {  
    Token string `json:"token"`  
}
```

别忘记执行`gf gen ctrl`哦！

## 添加登录逻辑
---
定义一个随机的字符串`JwtKey`用作签名。
*utility/jwt.go*
```go
package utility  
  
var JwtKey = []byte("db03d23b03ec405793b38f10592a2f34")
```

编写核心逻辑，使用`github.com/golang-jwt/jwt/v5`生成`Token`。
*internal/logic/users/account.go*
```go
package users  
  
import (  
    "context"  
    "errors"
    "time"  
    
    "github.com/golang-jwt/jwt/v5"
    
    "star/internal/dao"    
    "star/internal/model/entity"    
    "star/utility"
)
  
type UserClaims struct {  
    Id       uint  
    Username string  
    jwt.RegisteredClaims  
}  
  
func Login(ctx context.Context, username, password string) (tokenString string, err error) {  
    var user entity.Users  
    err = dao.Users.Ctx(ctx).Where("username", username).Scan(&user)  
    if err != nil {  
       return "", errors.New("用户名或密码错误")  
    }  
  
    if user.Id == 0 {  
       return "", errors.New("用户不存在")  
    }  
  
    // 将密码加密后与数据库中的密码进行比对  
    if user.Password != encryptPassword(password) {  
       return "", errors.New("用户名或密码错误")  
    }  
  
    // 生成token  
    userClaims := &UserClaims{  
       Id:       user.Id,  
       Username: user.Username,  
       RegisteredClaims: jwt.RegisteredClaims{  
          ExpiresAt: jwt.NewNumericDate(time.Now().Add(6 * time.Hour)),  
       },  
    }  
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, userClaims)  
    return token.SignedString(utility.JwtKey)  
}
```

从上面的代码可以看到，我们需要声明一个结构体`UserClaims`保存我们需要签名的信息，并且在最后使用`JwtKey`生成签名。
```go
type UserClaims struct {  
    Id       uint  
    Username string  
    jwt.RegisteredClaims  
}```

生成签名必须提供一个过期时间：
```go
userClaims := &UserClaims{  
	...
    ExpiresAt: jwt.NewNumericDate(time.Now().Add(6 * time.Hour)),  
}  
```

## 控制器调用Logic
---
*internal/controller/users/users_v1_login.go*
```go
package users  
  
import (  
    "context"  
    
    "star/internal/logic/users"  
    "star/api/users/v1"
)  
  
func (c *ControllerV1) Login(ctx context.Context, req *v1.LoginReq) (res *v1.LoginRes, err error) {  
    token, err := users.Login(ctx, req.Username, req.Password)  
    if err != nil {  
       return  
    }  
    return &v1.LoginRes{Token: token}, nil  
}
```

测试接口是否正常工作：
```bash
$ curl -X POST http://127.0.0.1:8000/v1/users/login -H "Content-Type: application/json" -d "{\"username\":\"oldme\", \"password\":\"123456\"}"

{
	"code":0,
	"message":"",
	"data":{
		"token":"eyJhbGciOi...ZY_ATzOU"
	}
}
```

然后我们就可以拿接口换取用户信息了。